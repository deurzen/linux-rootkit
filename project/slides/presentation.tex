\documentclass{i20lecture}
\usepackage{listings}

\subtitle{LiveDM - Proof of Concept}

\begin{document}

\frame{\titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Agenda}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \begin{enumerate}
   \item Background
    \begin{itemize}
        \item Dynamic Kernel Memory
        \item LiveDM
    \end{itemize}
    \item Approach
    \item Results
    \item Discussion / Questions
  \end{enumerate}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \framesubtitle{Dynamic Kernel Memory}
  
  \begin{itemize}
    \item Dynamic kernel memory is..
    \begin{itemize}
\pause
    \item ..hard to make sense of -- usually, no type information is available
\pause
    \item ..changing \textit{very} frequently
\pause
    \item ..difficult to analyze!
    \end{itemize}
\pause
    \item How can we make analysis easier?
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Overview}
  
  \begin{itemize}
    \item LiveDM seeks to overcome the previous issues through Virtual Machine Introspection
\pause
    \item Memory allocation events can be intercepted from a
\pause
    \item Going from there, LiveDM is able to create a memory map
\pause
    \item This map even includes type information!
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Overview}
  
  \begin{itemize}
    \item Three phases \footnote{The word 'phase' is not the best pick here} exist to create the mapping:
    \begin{enumerate}
\pause
     \item Gathering of necessary values
\pause
     \item Determining scope of interpretation
\pause
     \item Data type interpretation
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Phase 1}
  
  \begin{itemize}
    \item Phase 1 is comprised of..
    \begin{itemize}
\pause
     \item ..intercepting a set of memory allocation/freeing functions
\pause
     \item ..retrieving the requested size, as well as the return value
\pause
     \item ..identifying the caller through the stack's return address
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Phase 2}
  
  \begin{itemize}
    \item In phase 2, the scope of memory monitoring is chosen
    \begin{itemize}
\pause
     \item Offer snapshots of the memory map (containing type and size for allocated memory)
     \begin{itemize}
      \item We offer this in our PoC
     \end{itemize}
\pause
     \item Trace every memory access on known memory blocks
     \begin{itemize}
      \item We are able to showcase that on a small example
     \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Phase 3}
  
  \begin{itemize}
    \item In phase 3, the caller's address is translated into a type
\pause
    \begin{itemize}
     \item Relies on instrumenting GCC to retrieve abstract syntax tree (AST)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Motivation}
  
  \begin{itemize}
    \item Why do we need this information? Possible answers include..
    \begin{enumerate}
\pause
     \item To make dynamic memory less transparent
\pause
     \item To utilize this information for debugging
\pause
     \item \textcolor{yellow}{To utilize this information for rootkit detection}
    \end{enumerate}
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \framesubtitle{VMM}
  
  \begin{itemize}
   \item Since introspection techniques are required, we need a VMM
\pause
    \begin{itemize}
    \item Xen
    \item KVM
    \item QEMU (our pick; introspection done with GDB)
    \item ..
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{Implementing Phase 1}
    
    \begin{itemize}
     \item Intercepting allocation functions is easy: breakpoints
     \begin{itemize}
\pause
      \item Has a significant performance overhead, but system is still usable
\pause
      \item Possible improvement: hardware breakpoints
\pause
      \item Only part of GDB's Python API since 21st January 2021..
     \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing Phase 1}
    
    \begin{itemize}
     \item To retrieve the size parameter, we can rely on the System V calling convention
\pause
     \begin{itemize}
      \item As the size is not always the first argument, we build a dictionary:
     \end{itemize}
    \end{itemize}
    \begin{lstlisting}
    break_arg = {
        "kmem_cache_alloc_trace": "rdx",
        "kmalloc_order": "rdi"
        [...]
    }
    \end{lstlisting}
\pause
    \begin{itemize}
     \item Return values are gathered by additionally breaking on return instructions
     \begin{itemize}
\pause
     \item Only one will be generated per function
     \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{Implementing Phase 2}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion / Questions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \begin{center}
    \LARGE \dots
  \end{center}
\end{frame}



\end{document}
