\documentclass{i20lecture}
\usepackage{listings}

\subtitle{LiveDM --- Proof of Concept}

\begin{document}

\frame{\titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Agenda}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \begin{enumerate}
   \item Background
    \begin{itemize}
        \item Dynamic Kernel Memory
        \item LiveDM
    \end{itemize}
    \item Approach
    \item Results
    \item Discussion / Questions
  \end{enumerate}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \framesubtitle{Dynamic Kernel Memory}

  \begin{itemize}
    \item Dynamic kernel memory is...
    \begin{itemize}
\pause
    \item ...hard to make sense of -- usually, no type information is available
\pause
	\item ...constantly changing -- it's dynamic, after all
\pause
    \item ...difficult to analyze!
    \end{itemize}
\pause
    \item How can we make analysis easier?
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM --- Overview}

  \begin{itemize}
	\item LiveDM seeks to overcome these issues through Virtual Machine Introspection (VMI)
	\pause
	\begin{itemize}
		\item Monitor the runtime state of a system-level VM
		\pause
		\item Without altering the guest OS
	\end{itemize}
\pause
    \item Memory allocation events can be intercepted
\pause
    \item Going from there, LiveDM is able to create a memory map
	\begin{itemize}
		\pause
		\item This map includes type information!
	\end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM --- Overview}

  \begin{itemize}
    \item Three distinct stages to create the mapping:
    \begin{enumerate}
\pause
     \item Gathering of necessary values
\pause
     \item Determining scope of interpretation
\pause
     \item Performing type interpretation
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM --- Stage 1}

  \begin{itemize}
    \item Stage 1 is comprised of...
    \begin{itemize}
     \item ...intercepting a set of memory allocation/deallocation functions
\pause
     \item ...retrieving the requested allocation size, as well as the return value
\pause
	 \item ...identifying the caller (call site) through the stack's return address
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM --- Stage 2}

  \begin{itemize}
    \item In stage 2, the scope of memory monitoring is chosen
    \begin{itemize}
\pause
     \item Offer snapshots of the memory map (containing type and size for allocated memory)
     \begin{itemize}
		 \item We offer this in our PoC (\lstinline|rk-print-mem| and \lstinline|rk-data <address>|)
     \end{itemize}
\pause
	 \item Trace every memory (write) access on known (vulnerable) memory blocks
     \begin{itemize}
      \item Warn when critical values are written to traced blocks
      \item We are able to showcase this in a small demo
     \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM --- Stage 3}

  \begin{itemize}
    \item In stage 3, the caller's address is translated into a type
\pause
    \begin{itemize}
     \item Relies on instrumenting GCC to retrieve abstract syntax tree (AST)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM --- Motivation}

  \begin{itemize}
    \item Why do we need this information? Possible answers include...
    \begin{enumerate}
\pause
     \item To make dynamic memory less transparent
\pause
     \item To utilize this information for debugging
\pause
     \item \textcolor{yellow}{To utilize this information for rootkit detection}
    \end{enumerate}
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \begin{enumerate}
   \item Background
    \item Approach
    \begin{itemize}
        \item Tools
        \item Implementing stage 1
        \item Implementing stage 2
        \item Implementing stage 3
    \end{itemize}
    \item Results
    \item Discussion / Questions
  \end{enumerate}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{Tools}

  \begin{itemize}
   \item Since introspection techniques are required, we need a VMM
\pause
    \begin{itemize}
    \item Xen
    \item KVM
	\item \textcolor{yellow}{QEMU} (in vivo introspection using GDB)
    \item ...
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{Implementing stage 1}

    \begin{itemize}
	\item Intercepting allocations is easy: non-blocking \textbf{breakpoints}
     \begin{itemize}
\pause
      \item Has a significant performance overhead, but system is still usable
\pause
      \item Possible improvement: hardware breakpoints
\pause
        \begin{itemize}
			\item Limited to a small amount
\pause
            \item Only part of GDB's Python API since January 21st, 2021...
        \end{itemize}
     \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing stage 1}

    \begin{itemize}
     \item To retrieve the size of the allocation, we can rely on the System V calling convention
\pause
     \begin{itemize}
      \item As the size is not always the first argument, we build a dictionary:
     \end{itemize}
    \end{itemize}
    \begin{lstlisting}
    break_arg = {
        "kmem_cache_alloc_trace": "rdx",
        "kmalloc_order": "rdi"
        [...]
    }
    \end{lstlisting}
\pause
	\begin{itemize}
		\item Return values are gathered by additionally breaking on return instructions
		\pause
		\begin{itemize}
			\item Look for \lstinline|ret{,q}| instruction's offset from function entry in the disassembly
			\pause
			\item Break on \lstinline|<function entry> + <ret offset>|
			\pause
			\item Retrieve return value from \lstinline|$rax|
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{Implementing stage 1}

    \begin{itemize}
     \item LiveDM relies on the return address on the stack
\pause
     \item Instead, we walk frame by frame up the stack and retrieve the file name and line number at the assignment location
\pause
     \begin{itemize}
      \item More on that later...
     \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing stage 2}

    \begin{enumerate}
     \item Snapshot-based approach
\pause
     \begin{itemize}
      \item Since we already store everything gathered, this is readily available
\pause
      \item Currently allocated memory can be listed with \lstinline|rk-print-mem|:
     \end{itemize}
    \end{enumerate}
    \begin{lstlisting}
    > rk-print-mem
      type: struct task_struct *, size: 3776 B, addr: 0xffff9e65bb961d80, caller: ./kernel/fork.c:812
      type: struct fdtable *, size: 56 B, addr: 0xffff9e65bc7d7280, caller: ./fs/file.c:111
    \end{lstlisting}
	RK-DATA <ADDRESS>
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing stage 2}

    \begin{enumerate}
     \setcounter{enumi}{1}
     \item Memory-access tracing
\pause
    \begin{itemize}
     \item Would require some advanced techniques (e.g., page unmapping) for full coverage
\pause
    \item Not feasible within the given time frame
\pause
    \item Instead, we will demonstrate a small example later based on \textit{hardware} watchpoints
    \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing stage 3}
    \begin{itemize}
     \item Translation of call sites to types
	 \pause
     \item Possible approaches:
     \begin{itemize}
\pause
      \item Instrumenting \texttt{gcc} to extract AST (LiveDM)
\pause
      \item Use \texttt{clang} to generate an AST without instrumentation
\pause
	  \item \textcolor{yellow}{Utilize GDB's \texttt{whatis} command to statically pre-compute type dictionary}
     \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing stage 3}
    \begin{itemize}
     \item Process for generating the type dictionary: \footnote{Fully automated, since specific to kernel sources version, build options, and compiler optimizations}
\pause
     \begin{enumerate}
      \item Find all occurences of function calls we are interested in using \texttt{cscope}
\pause
      \item Iterate the generated occurences using Python; execute \texttt{whatis} on every assigned-to symbol
      \begin{itemize}
\pause
       \item Assumption: debug symbols for current kernel sources are available
\pause
       \item Compound type access chains (e.g., \lstinline|desc->inbuf|) have to be recursively resolved
	\pause
	   \item We only require the type of the last dereferenced field, as that is what's being assigned to
      \end{itemize}
\pause
      \item Store the results in a dictionary
\pause
      \item Use this precompiled type dictionary in our runtime script
\pause
     \end{enumerate}
    \end{itemize}
    \begin{lstlisting}
     "./arch/x86/kernel/e820.c:675": "type = struct e820_table *",
     "./arch/x86/kernel/e820.c:681": "type = struct e820_table *"
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing stage 3}
    \begin{itemize}
     \item Once a breakpoint is encountered, we can walk the stack with gdb...
    \end{itemize}
\pause
    \begin{lstlisting}
    #0  __kmalloc (size=168, flags=6291456) at ./mm/slub.c:3784
    #1  0xffffffffa9384095 in kmalloc (flags=<optimized out>, size=<optimized out>) at ./include/linux/slab.h:520
    #2  bio_alloc_bioset (gfp_mask=6291456, nr_iovecs=<optimized out>, bs=0x0) at ./block/bio.c:452
    \end{lstlisting}
\pause
    \begin{itemize}
     \item ...and match the \texttt{file:line} descriptor to a type without expensive computations
    \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Demo 1 - Allocation \& Deallocation}
    \begin{itemize}
     \item We will demonstrate the output in a running system now
     \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Demo 2 - Rootkit Detection}
    \begin{itemize}
     \item We will demonstrate the output in a running system now
     \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion / Questions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \begin{center}
    \LARGE \dots
  \end{center}
\end{frame}



\end{document}
