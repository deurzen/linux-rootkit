\documentclass{i20lecture}
\usepackage{listings}

\subtitle{LiveDM - Proof of Concept}

\begin{document}

\frame{\titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Agenda}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \begin{enumerate}
   \item Background
    \begin{itemize}
        \item Dynamic Kernel Memory
        \item LiveDM
    \end{itemize}
    \item Approach
    \item Results
    \item Discussion / Questions
  \end{enumerate}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \framesubtitle{Dynamic Kernel Memory}
  
  \begin{itemize}
    \item Dynamic kernel memory is..
    \begin{itemize}
\pause
    \item ..hard to make sense of -- usually, no type information is available
\pause
    \item ..changing \textit{very} frequently
\pause
    \item ..difficult to analyze!
    \end{itemize}
\pause
    \item How can we make analysis easier?
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Overview}
  
  \begin{itemize}
    \item LiveDM seeks to overcome the previous issues through Virtual Machine Introspection
\pause
    \item Memory allocation events can be intercepted from a
\pause
    \item Going from there, LiveDM is able to create a memory map
\pause
    \item This map even includes type information!
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Overview}
  
  \begin{itemize}
    \item Three phases \footnote{The word 'phase' is not the best pick here} exist to create the mapping:
    \begin{enumerate}
\pause
     \item Gathering of necessary values
\pause
     \item Determining scope of interpretation
\pause
     \item Data type interpretation
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Phase 1}
  
  \begin{itemize}
    \item Phase 1 is comprised of..
    \begin{itemize}
\pause
     \item ..intercepting a set of memory allocation/freeing functions
\pause
     \item ..retrieving the requested size, as well as the return value
\pause
     \item ..identifying the caller through the stack's return address
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Phase 2}
  
  \begin{itemize}
    \item In phase 2, the scope of memory monitoring is chosen
    \begin{itemize}
\pause
     \item Offer snapshots of the memory map (containing type and size for allocated memory)
     \begin{itemize}
      \item We offer this in our PoC
     \end{itemize}
\pause
     \item Trace every memory access on known memory blocks
     \begin{itemize}
      \item We are able to showcase that on a small example
     \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Phase 3}
  
  \begin{itemize}
    \item In phase 3, the caller's address is translated into a type
\pause
    \begin{itemize}
     \item Relies on instrumenting GCC to retrieve abstract syntax tree (AST)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{LiveDM - Motivation}
  
  \begin{itemize}
    \item Why do we need this information? Possible answers include..
    \begin{enumerate}
\pause
     \item To make dynamic memory less transparent
\pause
     \item To utilize this information for debugging
\pause
     \item \textcolor{yellow}{To utilize this information for rootkit detection}
    \end{enumerate}
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \framesubtitle{VMM}
  
  \begin{itemize}
   \item Since introspection techniques are required, we need a VMM
\pause
    \begin{itemize}
    \item Xen
    \item KVM
    \item QEMU (our pick; introspection done with GDB)
    \item ..
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{Implementing Phase 1}
    
    \begin{itemize}
     \item Intercepting allocation functions is easy: breakpoints
     \begin{itemize}
\pause
      \item Has a significant performance overhead, but system is still usable
\pause
      \item Possible improvement: hardware breakpoints
\pause
        \begin{itemize}
            \item Limited to a small number
\pause
            \item Only part of GDB's Python API since 21st January 2021..
        \end{itemize}
     \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing Phase 1}
    
    \begin{itemize}
     \item To retrieve the size parameter, we can rely on the System V calling convention
\pause
     \begin{itemize}
      \item As the size is not always the first argument, we build a dictionary:
     \end{itemize}
    \end{itemize}
    \begin{lstlisting}
    break_arg = {
        "kmem_cache_alloc_trace": "rdx",
        "kmalloc_order": "rdi"
        [...]
    }
    \end{lstlisting}
\pause
    \begin{itemize}
     \item Return values are gathered by additionally breaking on return instructions
     \begin{itemize}
\pause
     \item Only one will be generated per function
     \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{\insertsection}
  \framesubtitle{Implementing Phase 1}
    
    \begin{itemize}
     \item LiveDM relies on the return address on the stack
\pause
     \item Instead, we walk the unwinded stack and retrieve the \texttt{file:line} information
\pause
     \begin{itemize}
      \item More on that later..
     \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing Phase 2}
    
    \begin{enumerate}
     \item Snapshot-based approach
\pause
     \begin{itemize}
      \item Since we already store everything gathered, this is readily available
\pause
      \item Currently allocated memory can be listed with \texttt{rk-print-mem}:
     \end{itemize}
    \end{enumerate}
    \begin{lstlisting}
    > rk-print-mem 
      type: struct task_struct *, size: 3776 B, addr: 0xffff9e65bb961d80, caller: ./kernel/fork.c:812
      type: struct fdtable *, size: 56 B, addr: 0xffff9e65bc7d7280, caller: ./fs/file.c:111
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing Phase 2}
    
    \begin{enumerate}
     \setcounter{enumi}{1}
     \item Memory-access tracing
\pause
    \begin{itemize}
     \item Would require some advanced techniques (ex.: page unmapping) for full coverage
\pause
    \item Not feasible for the given time frame
\pause
    \item Instead, we will demonstrate a small example later based on \textit{hardware} watchpoints
    \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing Phase 3}
    \begin{itemize}
     \item Translation of call sites to types; possible approaches:
     \begin{itemize}
\pause
      \item Instrumenting \texttt{gcc} to extract AST (LiveDM)
\pause
      \item Using \texttt{clang} to generate an AST without instrumentation
\pause
      \item Abusing GDB's \texttt{whatis} command to statically pre-compute type dictionary (Our pick)
     \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing Phase 3}
    \begin{itemize}
     \item Process for generating the type dictionary: \footnote{Fully automated, since very specific to kernel  code version}
\pause
     \begin{enumerate}
      \item Find all occurences of function calls we are interested in using \texttt{cscope}
\pause
      \item Iterate the generated occurences in python; execute \texttt{whatis} on every variable
      \begin{itemize}
\pause
       \item Assumption: kernel symbols are loaded
\pause
       \item Compound types (example: \lstinline|desc->inbuf|) have to be resolved incrementally by us
      \end{itemize}
\pause
      \item Place the results in a dictionary; can be loaded by the 'main' python script
\pause
     \end{enumerate}
    \end{itemize}
    \begin{lstlisting}
     "./arch/x86/kernel/e820.c:675": "type = struct e820_table *",
     "./arch/x86/kernel/e820.c:681": "type = struct e820_table *"
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Implementing Phase 3}
    \begin{itemize}
     \item Once a breakpoint is encountered, we can walk the stack with gdb..
    \end{itemize}
\pause
    \begin{lstlisting}
    #0  __kmalloc (size=168, flags=6291456) at ./mm/slub.c:3784
    #1  0xffffffffa9384095 in kmalloc (flags=<optimized out>, size=<optimized out>) at ./include/linux/slab.h:520
    #2  bio_alloc_bioset (gfp_mask=6291456, nr_iovecs=<optimized out>, bs=0x0) at ./block/bio.c:452
    \end{lstlisting}
\pause
    \begin{itemize}
     \item ..and match the \texttt{file:line} descriptor to a type without expensive computations
    \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Demo 1 - Allocation \& Deallocation}
    \begin{itemize}
     \item We will demonstrate the output in a running system now
     \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}
  \framesubtitle{Demo 2 - Rootkit Detection}
    \begin{itemize}
     \item We will demonstrate the output in a running system now
     \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion / Questions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\insertsection}
  \begin{center}
    \LARGE \dots
  \end{center}
\end{frame}



\end{document}
